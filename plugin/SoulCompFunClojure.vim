function SoulCompFunClojure(findstart, base)
    if a:findstart
        let line = getline('.')
        let start = col('.') - 1
        while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\.\-]'
            let start -= 1
        endwhile
        return start
    else
        let res = []
        for k in s:cljlists
            if k =~ '^' . a:base
                call add(res, k)
            endif
        endfor
        return res
    endif
endfunction

let s:cljlists = [
\ "def",
\ "defn",
\ "map",
\ "filter",
\ "reduce",
\ "rest",
\ "first",
\ "defprotocol",
\ "defrecord",
\ "*",
\ "*1",
\ "*2",
\ "*3",
\ "*agent*",
\ "*allow-unresolved-vars*",
\ "*assert*",
\ "*clojure-version*",
\ "*command-line-args*",
\ "*compile-files*",
\ "*compile-path*",
\ "*current*",
\ "*e",
\ "*err*",
\ "*file*",
\ "*flush-on-newline*",
\ "*in*",
\ "*macro-meta*",
\ "*math-context*",
\ "*ns*",
\ "*out*",
\ "*print-dup*",
\ "*print-length*",
\ "*print-level*",
\ "*print-meta*",
\ "*print-readably*",
\ "*read-eval*",
\ "*sb*",
\ "*source-path*",
\ "*stack*",
\ "*state*",
\ "*use-context-classloader*",
\ "*warn-on-reflection*",
\ "+",
\ "-",
\ "->",
\ "->>",
\ "..",
\ "/",
\ "<",
\ "<=",
\ "=",
\ "==",
\ ">",
\ ">=",
\ "accessor",
\ "aclone",
\ "add-classpath",
\ "add-watch",
\ "agent",
\ "agent-errors",
\ "aget",
\ "alength",
\ "alias",
\ "all-ns",
\ "alter",
\ "alter-meta!",
\ "alter-var-root",
\ "amap",
\ "ancestors",
\ "and",
\ "append-child",
\ "apply",
\ "areduce",
\ "array-map",
\ "aset",
\ "aset-boolean",
\ "aset-byte",
\ "aset-char",
\ "aset-double",
\ "aset-float",
\ "aset-int",
\ "aset-long",
\ "aset-short",
\ "assert",
\ "assoc!",
\ "assoc",
\ "assoc-in",
\ "associative?",
\ "atom",
\ "attrs",
\ "await",
\ "await-for",
\ "await1",
\ "bases",
\ "bean",
\ "bigdec",
\ "bigint",
\ "binding",
\ "bit-and",
\ "bit-and-not",
\ "bit-clear",
\ "bit-flip",
\ "bit-not",
\ "bit-or",
\ "bit-set",
\ "bit-shift-left",
\ "bit-shift-right",
\ "bit-test",
\ "bit-xor",
\ "boolean",
\ "boolean-array",
\ "booleans",
\ "bound-fn",
\ "bound-fn*",
\ "branch?",
\ "butlast",
\ "byte",
\ "byte-array",
\ "bytes",
\ "cast",
\ "char",
\ "char-array",
\ "char-escape-string",
\ "char-name-string",
\ "char?",
\ "chars",
\ "children",
\ "chunk",
\ "chunk-append",
\ "chunk-buffer",
\ "chunk-cons",
\ "chunk-first",
\ "chunk-next",
\ "chunk-rest",
\ "chunked-seq?",
\ "class",
\ "class?",
\ "clear-agent-errors",
\ "clojure-version",
\ "coll?",
\ "comment",
\ "commute",
\ "comp",
\ "comparator",
\ "compare",
\ "compare-and-set!",
\ "compile",
\ "complement",
\ "concat",
\ "cond",
\ "condp",
\ "conj!",
\ "conj",
\ "cons",
\ "constantly",
\ "construct-proxy",
\ "contains?",
\ "content",
\ "content-handler",
\ "count",
\ "counted?",
\ "create-ns",
\ "create-struct",
\ "cycle",
\ "dec",
\ "decimal?",
\ "declare",
\ "definline",
\ "defmacro",
\ "defmethod",
\ "defmulti",
\ "defn-",
\ "defonce",
\ "defstruct",
\ "delay",
\ "delay?",
\ "deliver",
\ "deref",
\ "derive",
\ "descendants",
\ "destructure",
\ "difference",
\ "disj!",
\ "disj",
\ "dissoc!",
\ "dissoc",
\ "distinct",
\ "distinct?",
\ "doall",
\ "doc",
\ "dorun",
\ "doseq",
\ "dosync",
\ "dotimes",
\ "doto",
\ "double",
\ "double-array",
\ "doubles",
\ "down",
\ "drop",
\ "drop-last",
\ "drop-while",
\ "edit",
\ "element",
\ "emit",
\ "emit-element",
\ "empty",
\ "empty?",
\ "end?",
\ "ensure",
\ "enumeration-seq",
\ "eval",
\ "even?",
\ "every?",
\ "false?",
\ "ffirst",
\ "file-seq",
\ "find",
\ "find-doc",
\ "find-ns",
\ "find-var",
\ "float",
\ "float-array",
\ "float?",
\ "floats",
\ "flush",
\ "fn",
\ "fn?",
\ "fnext",
\ "for",
\ "force",
\ "format",
\ "future",
\ "future-call",
\ "future-cancel",
\ "future-cancelled?",
\ "future-done?",
\ "future?",
\ "gen-class",
\ "gen-interface",
\ "gensym",
\ "get",
\ "get-in",
\ "get-method",
\ "get-proxy-class",
\ "get-thread-bindings",
\ "get-validator",
\ "hash",
\ "hash-map",
\ "hash-set",
\ "identical?",
\ "identity",
\ "if-let",
\ "if-not",
\ "ifn?",
\ "import",
\ "in-ns",
\ "inc",
\ "index",
\ "init-proxy",
\ "insert-child",
\ "insert-left",
\ "insert-right",
\ "instance?",
\ "int",
\ "int-array",
\ "integer?",
\ "interleave",
\ "intern",
\ "interpose",
\ "intersection",
\ "into",
\ "into-array",
\ "ints",
\ "io!",
\ "isa?",
\ "iterate",
\ "iterator-seq",
\ "join",
\ "juxt",
\ "key",
\ "keys",
\ "keyword",
\ "keyword?",
\ "last",
\ "lazy-cat",
\ "lazy-seq",
\ "left",
\ "leftmost",
\ "lefts",
\ "let",
\ "letfn",
\ "line-seq",
\ "list",
\ "list*",
\ "list?",
\ "load",
\ "load-file",
\ "load-reader",
\ "load-string",
\ "loaded-libs",
\ "locking",
\ "long",
\ "long-array",
\ "longs",
\ "loop",
\ "macroexpand",
\ "macroexpand-1",
\ "make-array",
\ "make-hierarchy",
\ "make-node",
\ "map-invert",
\ "map?",
\ "mapcat",
\ "max",
\ "max-key",
\ "memfn",
\ "memoize",
\ "merge",
\ "merge-with",
\ "meta",
\ "method-sig",
\ "methods",
\ "min",
\ "min-key",
\ "mod",
\ "name",
\ "namespace",
\ "neg?",
\ "newline",
\ "next",
\ "next",
\ "nfirst",
\ "nil?",
\ "nnext",
\ "node",
\ "not",
\ "not-any?",
\ "not-empty",
\ "not-every?",
\ "not=",
\ "ns",
\ "ns-aliases",
\ "ns-imports",
\ "ns-interns",
\ "ns-map",
\ "ns-name",
\ "ns-publics",
\ "ns-refers",
\ "ns-resolve",
\ "ns-unalias",
\ "ns-unmap",
\ "nth",
\ "nthnext",
\ "num",
\ "number?",
\ "odd?",
\ "or",
\ "parents",
\ "parse",
\ "partial",
\ "partition",
\ "path",
\ "pcalls",
\ "peek",
\ "persistent!",
\ "pmap",
\ "pop!",
\ "pop",
\ "pop-thread-bindings",
\ "pos?",
\ "pr",
\ "pr-str",
\ "prefer-method",
\ "prefers",
\ "prev",
\ "primitives-classnames",
\ "print",
\ "print-ctor",
\ "print-doc",
\ "print-dup",
\ "print-method",
\ "print-namespace-doc",
\ "print-simple",
\ "print-special-doc",
\ "print-str",
\ "printf",
\ "println",
\ "println-str",
\ "prn",
\ "prn-str",
\ "project",
\ "promise",
\ "proxy",
\ "proxy-call-with-super",
\ "proxy-mappings",
\ "proxy-name",
\ "proxy-super",
\ "push-thread-bindings",
\ "pvalues",
\ "quot",
\ "rand",
\ "rand-int",
\ "range",
\ "ratio?",
\ "rational?",
\ "rationalize",
\ "re-find",
\ "re-groups",
\ "re-matcher",
\ "re-matches",
\ "re-pattern",
\ "re-seq",
\ "read",
\ "read-line",
\ "read-string",
\ "ref",
\ "ref-history-count",
\ "ref-max-history",
\ "ref-min-history",
\ "ref-set",
\ "refer",
\ "refer-clojure",
\ "release-pending-sends",
\ "rem",
\ "remove",
\ "remove",
\ "remove-method",
\ "remove-ns",
\ "remove-watch",
\ "rename",
\ "rename-keys",
\ "repeat",
\ "repeatedly",
\ "replace",
\ "replace",
\ "replicate",
\ "require",
\ "reset!",
\ "reset-meta!",
\ "resolve",
\ "resultset-seq",
\ "reverse",
\ "reversible?",
\ "right",
\ "rightmost",
\ "rights",
\ "root",
\ "rseq",
\ "rsubseq",
\ "second",
\ "select",
\ "select-keys",
\ "send",
\ "send-off",
\ "seq",
\ "seq-zip",
\ "seq?",
\ "seque",
\ "sequence",
\ "sequential?",
\ "set",
\ "set-validator!",
\ "set?",
\ "short",
\ "short-array",
\ "shorts",
\ "shutdown-agents",
\ "slurp",
\ "some",
\ "sort",
\ "sort-by",
\ "sorted-map",
\ "sorted-map-by",
\ "sorted-set",
\ "sorted-set-by",
\ "sorted?",
\ "special-form-anchor",
\ "special-symbol?",
\ "split-at",
\ "split-with",
\ "startparse-sax",
\ "str",
\ "stream?",
\ "string?",
\ "struct",
\ "struct-map",
\ "subs",
\ "subseq",
\ "subvec",
\ "supers",
\ "swap!",
\ "symbol",
\ "symbol?",
\ "sync",
\ "syntax-symbol-anchor",
\ "tag",
\ "take",
\ "take-last",
\ "take-nth",
\ "take-while",
\ "test",
\ "the-ns",
\ "time",
\ "to-array",
\ "to-array-2d",
\ "trampoline",
\ "transient",
\ "tree-seq",
\ "true?",
\ "type",
\ "unchecked-add",
\ "unchecked-dec",
\ "unchecked-divide",
\ "unchecked-inc",
\ "unchecked-multiply",
\ "unchecked-negate",
\ "unchecked-remainder",
\ "unchecked-subtract",
\ "underive",
\ "union",
\ "unquote",
\ "unquote-splicing",
\ "up",
\ "update-in",
\ "update-proxy",
\ "use",
\ "val",
\ "vals",
\ "var-get",
\ "var-set",
\ "var?",
\ "vary-meta",
\ "vec",
\ "vector",
\ "vector-zip",
\ "vector?",
\ "when",
\ "when-first",
\ "when-let",
\ "when-not",
\ "while",
\ "with-bindings",
\ "with-bindings*",
\ "with-in-str",
\ "with-loading-context",
\ "with-local-vars",
\ "with-meta",
\ "with-open",
\ "with-out-str",
\ "with-precision",
\ "xml-seq",
\ "xml-zip",
\ "zero?",
\ "zipmap",
\ "zipper",
\ ]
